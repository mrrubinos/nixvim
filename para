#!/usr/bin/env bash

# PARA Method CLI Interface
# Provides command-line access to PARA notes, tasks, and logs

# Configuration - matches your Neovim PARA setup
# Can be overridden with environment variable PARA_BASE
PARA_BASE="${PARA_BASE:-$HOME/Documents/PARA}"
PARA_LOG="${PARA_LOG:-$PARA_BASE/log.md}"
PARA_LOG_ARCHIVE="${PARA_LOG_ARCHIVE:-$PARA_BASE/logs/archive}"
PARA_TASKS="${PARA_TASKS:-$PARA_BASE/tasks.md}"
PARA_TASKS_ARCHIVE="${PARA_TASKS_ARCHIVE:-$PARA_BASE/tasks_archive.md}"
PARA_PROJECTS="${PARA_PROJECTS:-$PARA_BASE/1_projects}"
PARA_AREAS="${PARA_AREAS:-$PARA_BASE/2_areas}"
PARA_RESOURCES="${PARA_RESOURCES:-$PARA_BASE/3_resources}"
PARA_ARCHIVE="${PARA_ARCHIVE:-$PARA_BASE/4_archive}"

# Colors for better readability
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Date format matching your Lua config
DATE_FORMAT="%Y-%m-%d"
TIME_FORMAT="%H:%M"
DATETIME_FORMAT="%Y-%m-%d %H:%M:%S"

# Ensure PARA directories exist
init_para() {
    mkdir -p "$PARA_BASE" "$PARA_LOG_ARCHIVE" "$PARA_PROJECTS" "$PARA_AREAS" "$PARA_RESOURCES" "$PARA_ARCHIVE"
    init_log_file
    init_tasks_file
}

# Initialize log file
init_log_file() {
    if [[ ! -f "$PARA_LOG" ]]; then
        cat > "$PARA_LOG" << EOF
# Log
Created: $(date +"$DATETIME_FORMAT")

EOF
        echo -e "${GREEN}Created log file: $PARA_LOG${NC}"
    fi
}

# Initialize tasks file
init_tasks_file() {
    if [[ ! -f "$PARA_TASKS" ]]; then
        cat > "$PARA_TASKS" << EOF
# Tasks
Created: $(date +"$DATETIME_FORMAT")

EOF
        echo -e "${GREEN}Created tasks file: $PARA_TASKS${NC}"
    fi
}

# Get today's date
get_date() {
    date +"$DATE_FORMAT"
}

# Get current time
get_time() {
    date +"$TIME_FORMAT"
}

# Get current datetime
get_datetime() {
    date +"$DATETIME_FORMAT"
}

# Open log file
open_log() {
    init_log_file
    
    if [[ "$1" == "--edit" ]]; then
        ${EDITOR:-nvim} "$PARA_LOG"
    else
        echo -e "${CYAN}Log file: $PARA_LOG${NC}"
        echo "---"
        tail -n 50 "$PARA_LOG"
    fi
}

# Add a log entry
add_log_entry() {
    local entry="$*"
    if [[ -z "$entry" ]]; then
        echo -e "${RED}Error: No log entry provided${NC}"
        echo "Usage: $0 log <entry text>"
        exit 1
    fi
    
    init_log_file
    
    echo "$(get_datetime) - $entry" >> "$PARA_LOG"
    echo -e "${GREEN}✓ Log entry added${NC}"
}

# Archive log entries
archive_log() {
    local cutoff_date="$1"
    if [[ -z "$cutoff_date" ]]; then
        read -p "Archive entries before date (YYYY-MM-DD): " cutoff_date
    fi
    
    if [[ ! "$cutoff_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        echo -e "${RED}Invalid date format. Use YYYY-MM-DD${NC}"
        exit 1
    fi
    
    if [[ ! -f "$PARA_LOG" ]]; then
        echo -e "${RED}Log file not found${NC}"
        exit 1
    fi
    
    # Create archive
    local archive_file="$PARA_LOG_ARCHIVE/log_archive_$(date +%Y%m%d_%H%M%S).md"
    mkdir -p "$PARA_LOG_ARCHIVE"
    
    # Split log into archive and current
    local temp_current=$(mktemp)
    local temp_archive=$(mktemp)
    
    echo "# Archived Log Entries" > "$temp_archive"
    echo "Archived: $(get_datetime)" >> "$temp_archive"
    echo "Entries before: $cutoff_date" >> "$temp_archive"
    echo "" >> "$temp_archive"
    
    while IFS= read -r line; do
        if [[ "$line" =~ ^([0-9]{4}-[0-9]{2}-[0-9]{2}) ]]; then
            local entry_date="${BASH_REMATCH[1]}"
            if [[ "$entry_date" < "$cutoff_date" ]]; then
                echo "$line" >> "$temp_archive"
            else
                echo "$line" >> "$temp_current"
            fi
        elif [[ "$line" =~ ^# || "$line" =~ ^Created: ]]; then
            echo "$line" >> "$temp_current"
        else
            echo "$line" >> "$temp_current"
        fi
    done < "$PARA_LOG"
    
    # Save files
    mv "$temp_archive" "$archive_file"
    mv "$temp_current" "$PARA_LOG"
    
    echo -e "${GREEN}✓ Archived entries to $archive_file${NC}"
}

# Add a task with priority
add_task() {
    local priority=""
    local description=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --critical|-A)
                priority="A"
                shift
                ;;
            --high|-B)
                priority="B"
                shift
                ;;
            --normal|-C)
                priority="C"
                shift
                ;;
            --low|-D)
                priority="D"
                shift
                ;;
            --someday|-E)
                priority="E"
                shift
                ;;
            *)
                description="$description $1"
                shift
                ;;
        esac
    done
    
    description="${description# }" # Trim leading space
    
    if [[ -z "$description" ]]; then
        echo -e "${RED}Error: No task description provided${NC}"
        echo "Usage: $0 task [--critical|-A|--high|-B|--normal|-C|--low|-D|--someday|-E] <description>"
        exit 1
    fi
    
    # If no priority specified, ask for it
    if [[ -z "$priority" ]]; then
        echo -e "${CYAN}Select priority:${NC}"
        select pri in "A - Critical" "B - High" "C - Normal" "D - Low" "E - Someday"; do
            priority="${pri:0:1}"
            break
        done
    fi
    
    # Build task line
    local task_line
    if [[ "$priority" == "C" ]]; then
        # Normal priority - no prefix
        task_line="- [ ] $description"
    else
        task_line="[$priority] - [ ] $description"
    fi
    
    add_task_to_file "$task_line"
}

# Select project for task linking
select_project_for_task() {
    local base_task="$1"
    local projects=()
    
    # Get project names
    if [[ -d "$PARA_PROJECTS" ]]; then
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                local name=$(basename "$file" .md)
                projects+=("$name")
            fi
        done < <(find "$PARA_PROJECTS" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort)
    fi
    
    if [[ ${#projects[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No projects found${NC}"
        add_task_to_file "$base_task"
        return
    fi
    
    echo -e "${CYAN}Select project:${NC}"
    select project in "${projects[@]}"; do
        if [[ -n "$project" ]]; then
            local task_line="$base_task (project: $project)"
            add_task_to_file "$task_line"
            break
        fi
    done
}

# Select area for task linking  
select_area_for_task() {
    local base_task="$1"
    local areas=()
    mapfile -t areas < <(get_areas)
    
    if [[ ${#areas[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No areas found${NC}"
        add_task_to_file "$base_task"
        return
    fi
    
    echo -e "${CYAN}Select area:${NC}"
    select area in "${areas[@]}"; do
        if [[ -n "$area" ]]; then
            # Remove trailing slash if directory
            area="${area%/}"
            local task_line="$base_task (area: $area)"
            add_task_to_file "$task_line"
            break
        fi
    done
}

# Add task to tasks file and sort
add_task_to_file() {
    local task_line="$1"
    
    # Ensure tasks file exists
    init_tasks_file
    
    # Add task
    echo "$task_line" >> "$PARA_TASKS"
    
    # Sort tasks (header stays at top)
    local temp=$(mktemp)
    # Extract header
    head -n 3 "$PARA_TASKS" > "$temp"
    # Sort tasks
    tail -n +4 "$PARA_TASKS" | sort >> "$temp"
    mv "$temp" "$PARA_TASKS"
    
    echo -e "${GREEN}✓ Task added to tasks.md${NC}"
}

# Archive completed tasks
archive_done_tasks() {
    if [[ ! -f "$PARA_TASKS" ]]; then
        echo -e "${RED}Tasks file not found${NC}"
        exit 1
    fi
    
    # Separate done and pending tasks
    local temp_pending=$(mktemp)
    local temp_done=$(mktemp)
    
    # Keep header in pending
    head -n 3 "$PARA_TASKS" > "$temp_pending"
    
    # Process tasks
    tail -n +4 "$PARA_TASKS" | while IFS= read -r line; do
        if [[ "$line" =~ \[x\] ]]; then
            echo "$line" >> "$temp_done"
        elif [[ -n "$line" ]]; then
            echo "$line" >> "$temp_pending"
        fi
    done
    
    # Check if there are done tasks
    if [[ ! -s "$temp_done" ]]; then
        echo -e "${YELLOW}No completed tasks to archive${NC}"
        rm "$temp_pending" "$temp_done"
        return
    fi
    
    # Append to archive
    if [[ ! -f "$PARA_TASKS_ARCHIVE" ]]; then
        echo "# Archived Tasks" > "$PARA_TASKS_ARCHIVE"
        echo "" >> "$PARA_TASKS_ARCHIVE"
    fi
    
    echo "" >> "$PARA_TASKS_ARCHIVE"
    echo "## Archived on $(get_datetime)" >> "$PARA_TASKS_ARCHIVE"
    cat "$temp_done" >> "$PARA_TASKS_ARCHIVE"
    
    # Update tasks file
    mv "$temp_pending" "$PARA_TASKS"
    rm "$temp_done"
    
    local count=$(wc -l < "$temp_done" 2>/dev/null || echo 0)
    echo -e "${GREEN}✓ Archived $count completed tasks${NC}"
}

# Create a note
create_note() {
    local category=""
    local title=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --project|-p)
                category="Projects"
                shift
                ;;
            --area|-a)
                category="Areas"
                shift
                ;;
            --resource|-r)
                category="Resources"
                shift
                ;;
            *)
                title="$title $1"
                shift
                ;;
        esac
    done
    
    title="${title# }" # Trim leading space
    
    if [[ -z "$title" ]]; then
        echo -e "${RED}Error: No note title provided${NC}"
        echo "Usage: $0 note [--project|--area|--resource] <title>"
        exit 1
    fi
    
    if [[ -z "$category" ]]; then
        echo -e "${YELLOW}Select category:${NC}"
        select cat in "Projects" "Areas" "Resources"; do
            category="$cat"
            break
        done
    fi
    
    # Generate filename
    local filename="$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g').md"
    local dir
    case $category in
        Projects) dir="$PARA_PROJECTS" ;;
        Areas) dir="$PARA_AREAS" ;;
        Resources) dir="$PARA_RESOURCES" ;;
    esac
    
    local filepath="$dir/$filename"
    
    # Create note with template
    cat > "$filepath" << EOF
# $title

Created: $(date +"%Y-%m-%d %H:%M")
Category: $category
Tags: 

---

## Summary

## Content

## References

EOF
    
    echo -e "${GREEN}✓ Note created: $filepath${NC}"
    
    # Open in editor if --edit flag provided
    if [[ "$1" == "--edit" ]]; then
        ${EDITOR:-nvim} "$filepath"
    fi
}

# Search notes by name
search_notes_by_name() {
    local query="$*"
    if [[ -z "$query" ]]; then
        echo -e "${RED}Error: No search query provided${NC}"
        echo "Usage: $0 search-name <query>"
        exit 1
    fi
    
    echo -e "${CYAN}Searching note names for: '$query'${NC}"
    echo "---"
    
    find "$PARA_BASE" -name "*${query}*" -type f -name "*.md" | while read -r file; do
        echo "${file#$PARA_BASE/}"
    done
}

# Search notes by content
search_notes_by_content() {
    local query="$*"
    if [[ -z "$query" ]]; then
        echo -e "${RED}Error: No search query provided${NC}"
        echo "Usage: $0 search <query>"
        exit 1
    fi
    
    echo -e "${CYAN}Searching note contents for: '$query'${NC}"
    echo "---"
    
    # Use ripgrep if available, otherwise use grep
    if command -v rg &> /dev/null; then
        rg --type md -C 2 --color=always "$query" "$PARA_BASE"
    else
        grep -r --include="*.md" -n --color=always -C 2 "$query" "$PARA_BASE"
    fi
}

# List tasks
list_tasks() {
    if [[ ! -f "$PARA_TASKS" ]]; then
        echo -e "${YELLOW}No tasks file found${NC}"
        return
    fi
    
    echo -e "${CYAN}Tasks:${NC}"
    echo "---"
    
    # Skip header and display tasks with color coding
    tail -n +4 "$PARA_TASKS" | while IFS= read -r line; do
        if [[ -z "$line" ]]; then continue; fi
        
        if [[ "$line" =~ \[x\] ]]; then
            echo -e "${GREEN}✓${NC} ${line}"
        elif [[ "$line" =~ ^\[A\] ]]; then
            echo -e "${RED}●${NC} ${line}"
        elif [[ "$line" =~ ^\[B\] ]]; then
            echo -e "${YELLOW}●${NC} ${line}"
        elif [[ "$line" =~ ^\[C\] ]]; then
            echo -e "${BLUE}●${NC} ${line}"
        elif [[ "$line" =~ ^\[D\] ]]; then
            echo -e "${CYAN}●${NC} ${line}"
        elif [[ "$line" =~ ^\[E\] ]]; then
            echo -e "${MAGENTA}●${NC} ${line}"
        else
            echo -e "${BLUE}○${NC} ${line}"
        fi
    done
}


# Get dynamic list of areas
get_areas() {
    local areas=()
    
    # Get all .md files in areas directory
    if [[ -d "$PARA_AREAS" ]]; then
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                local name=$(basename "$file" .md)
                areas+=("$name")
            fi
        done < <(find "$PARA_AREAS" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort)
        
        # Also check for subdirectories
        while IFS= read -r dir; do
            if [[ -d "$dir" && "$dir" != "$PARA_AREAS" ]]; then
                local name=$(basename "$dir")
                areas+=("$name/")
            fi
        done < <(find "$PARA_AREAS" -maxdepth 1 -type d 2>/dev/null | sort)
    fi
    
    printf '%s\n' "${areas[@]}"
}

# Get dynamic list of projects
get_projects() {
    local projects=()
    
    # Get all .md files in projects directory
    if [[ -d "$PARA_PROJECTS" ]]; then
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                local name=$(basename "$file" .md)
                projects+=("$name")
            fi
        done < <(find "$PARA_PROJECTS" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort)
        
        # Also check for subdirectories
        while IFS= read -r dir; do
            if [[ -d "$dir" && "$dir" != "$PARA_PROJECTS" ]]; then
                local name=$(basename "$dir")
                projects+=("$name/")
            fi
        done < <(find "$PARA_PROJECTS" -maxdepth 1 -type d 2>/dev/null | sort)
    fi
    
    printf '%s\n' "${projects[@]}"
}

# Navigate to or create an area
goto_area() {
    local areas=()
    mapfile -t areas < <(get_areas)
    
    if [[ ${#areas[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No areas found. Create one?${NC}"
        read -p "Area name (or press Enter to cancel): " area_name
        if [[ -n "$area_name" ]]; then
            create_area "$area_name"
        fi
        return
    fi
    
    # Add option to create new area
    areas=("[Create New Area]" "${areas[@]}")
    
    echo -e "${CYAN}Select an area:${NC}"
    select area in "${areas[@]}"; do
        if [[ "$area" == "[Create New Area]" ]]; then
            read -p "New area name: " area_name
            if [[ -n "$area_name" ]]; then
                create_area "$area_name"
            fi
        elif [[ -n "$area" ]]; then
            if [[ "$area" == */ ]]; then
                # It's a directory
                ${EDITOR:-nvim} "$PARA_AREAS/${area%/}"
            else
                # It's a file
                ${EDITOR:-nvim} "$PARA_AREAS/$area.md"
            fi
        fi
        break
    done
}

# Navigate to or create a project
goto_project() {
    local projects=()
    mapfile -t projects < <(get_projects)
    
    if [[ ${#projects[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No projects found. Create one?${NC}"
        read -p "Project name (or press Enter to cancel): " project_name
        if [[ -n "$project_name" ]]; then
            create_project "$project_name"
        fi
        return
    fi
    
    # Add option to create new project
    projects=("[Create New Project]" "${projects[@]}")
    
    echo -e "${CYAN}Select a project:${NC}"
    select project in "${projects[@]}"; do
        if [[ "$project" == "[Create New Project]" ]]; then
            read -p "New project name: " project_name
            if [[ -n "$project_name" ]]; then
                create_project "$project_name"
            fi
        elif [[ -n "$project" ]]; then
            if [[ "$project" == */ ]]; then
                # It's a directory
                ${EDITOR:-nvim} "$PARA_PROJECTS/${project%/}"
            else
                # It's a file
                ${EDITOR:-nvim} "$PARA_PROJECTS/$project.md"
            fi
        fi
        break
    done
}

# Create a new area
create_area() {
    local name="$1"
    local filename=$(echo "$name" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g').md
    local filepath="$PARA_AREAS/$filename"
    
    if [[ -f "$filepath" ]]; then
        echo -e "${YELLOW}Area already exists: $name${NC}"
        ${EDITOR:-nvim} "$filepath"
        return
    fi
    
    cat > "$filepath" << EOF
# Area: $name

Created: $(date +"%Y-%m-%d %H:%M")

## Overview


## Responsibilities


## Standards & Maintenance


## Regular Tasks
- [ ] 

## Resources


## Notes

EOF
    
    echo -e "${GREEN}✓ Area created: $name${NC}"
    ${EDITOR:-nvim} "$filepath"
}

# Create a new project
create_project() {
    local name="$1"
    local filename=$(echo "$name" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g').md
    local filepath="$PARA_PROJECTS/$filename"
    
    if [[ -f "$filepath" ]]; then
        echo -e "${YELLOW}Project already exists: $name${NC}"
        ${EDITOR:-nvim} "$filepath"
        return
    fi
    
    cat > "$filepath" << EOF
# Project: $name

Created: $(date +"%Y-%m-%d %H:%M")
Status: Active
Due Date: 
Priority: Normal

## Objective


## Success Criteria


## Tasks
- [ ] 

## Resources


## Notes


## Retrospective

EOF
    
    echo -e "${GREEN}✓ Project created: $name${NC}"
    ${EDITOR:-nvim} "$filepath"
}



# Show statistics
show_stats() {
    echo -e "${CYAN}PARA Statistics:${NC}"
    echo "---"
    
    # Count files in each category
    local projects=$(find "$PARA_PROJECTS" -name "*.md" -type f 2>/dev/null | wc -l)
    local areas=$(find "$PARA_AREAS" -name "*.md" -type f 2>/dev/null | wc -l)
    local resources=$(find "$PARA_RESOURCES" -name "*.md" -type f 2>/dev/null | wc -l)
    local archive=$(find "$PARA_ARCHIVE" -name "*.md" -type f 2>/dev/null | wc -l)
    
    echo -e "${BOLD}Files:${NC}"
    echo -e "  Projects:  $projects"
    echo -e "  Areas:     $areas"
    echo -e "  Resources: $resources"
    echo -e "  Archive:   $archive"
    echo
    
    # Count log entries
    if [[ -f "$PARA_LOG" ]]; then
        local log_entries=$(grep -c "^[0-9]" "$PARA_LOG" 2>/dev/null || echo 0)
        echo -e "${BOLD}Log:${NC}"
        echo -e "  Entries: $log_entries"
    fi
    echo
    
    # Count tasks from tasks file
    if [[ -f "$PARA_TASKS" ]]; then
        local pending_tasks=$(grep -c "^.*\[ \]" "$PARA_TASKS" 2>/dev/null || echo 0)
        local completed_tasks=$(grep -c "^.*\[x\]" "$PARA_TASKS" 2>/dev/null || echo 0)
        local critical_tasks=$(grep -c "^\[A\]" "$PARA_TASKS" 2>/dev/null || echo 0)
        local high_tasks=$(grep -c "^\[B\]" "$PARA_TASKS" 2>/dev/null || echo 0)
        
        echo -e "${BOLD}Tasks:${NC}"
        echo -e "  Pending:   ${pending_tasks:-0}"
        echo -e "  Completed: ${completed_tasks:-0}"
        echo -e "  Critical:  ${critical_tasks:-0}"
        echo -e "  High:      ${high_tasks:-0}"
    else
        echo -e "${BOLD}Tasks:${NC}"
        echo -e "  No tasks file found - run 'para task' to create"
    fi
}

# Archive a project
archive_project() {
    local projects=()
    
    # Get project files
    if [[ -d "$PARA_PROJECTS" ]]; then
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                projects+=("$file")
            fi
        done < <(find "$PARA_PROJECTS" -maxdepth 1 -name "*.md" -type f 2>/dev/null | sort)
    fi
    
    if [[ ${#projects[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No projects found to archive${NC}"
        return
    fi
    
    echo -e "${CYAN}Select project to archive:${NC}"
    select project_path in "${projects[@]}"; do
        if [[ -n "$project_path" ]]; then
            local project_name=$(basename "$project_path")
            local archive_path="$PARA_ARCHIVE/$project_name"
            
            if [[ -f "$archive_path" ]]; then
                read -p "File already exists in archive. Overwrite? (y/n): " confirm
                if [[ "$confirm" != "y" ]]; then
                    echo "Archive cancelled"
                    return
                fi
            fi
            
            mv "$project_path" "$archive_path"
            echo -e "${GREEN}✓ Project archived: $project_name${NC}"
            break
        fi
    done
}

# Interactive menu
show_menu() {
    echo -e "${BOLD}${CYAN}PARA Method CLI${NC}"
    echo "---"
    PS3="Select an option: "
    
    options=(
        "Open log file"
        "Add log entry"
        "Archive log entries"
        "Open tasks file"
        "Add task"
        "Archive done tasks"
        "Search notes by name"
        "Search notes by content"
        "Archive a project"
        "List tasks"
        "Statistics"
        "Quit"
    )
    
    select opt in "${options[@]}"; do
        case $REPLY in
            1) open_log --edit; break ;;
            2) 
                read -p "Enter log entry: " entry
                add_log_entry "$entry"
                break
                ;;
            3) archive_log; break ;;
            4) ${EDITOR:-nvim} "$PARA_TASKS"; break ;;
            5)
                read -p "Task description: " desc
                add_task "$desc"
                break
                ;;
            6) archive_done_tasks; break ;;
            7)
                read -p "Search names for: " query
                search_notes_by_name "$query"
                break
                ;;
            8)
                read -p "Search contents for: " query
                search_notes_by_content "$query"
                break
                ;;
            9) archive_project; break ;;
            10) list_tasks; break ;;
            11) show_stats; break ;;
            12) echo "Goodbye!"; exit 0 ;;
            *) echo "Invalid option" ;;
        esac
    done
}

# Help message
show_help() {
    cat << EOF
${BOLD}PARA Method CLI${NC}

${BOLD}Usage:${NC}
  $(basename "$0") [command] [options]

${BOLD}Commands:${NC}
  ${CYAN}log${NC} [entry]                 Add a log entry
  ${CYAN}log-archive${NC} [date]          Archive log entries before date
  ${CYAN}task${NC} [options] <desc>       Add a task
  ${CYAN}task-archive${NC}                Archive completed tasks
  ${CYAN}note${NC} [options] <title>      Create a note
  ${CYAN}project${NC}                     Navigate/create projects
  ${CYAN}project-archive${NC}             Archive a project
  ${CYAN}area${NC}                        Navigate/create areas
  ${CYAN}search-name${NC} <query>         Search notes by name
  ${CYAN}search${NC} <query>              Search notes by content
  ${CYAN}list${NC}                        List tasks
  ${CYAN}stats${NC}                       Show statistics
  ${CYAN}menu${NC}                        Interactive menu
  ${CYAN}edit-log${NC}                    Open log file in editor
  ${CYAN}edit-tasks${NC}                  Open tasks file in editor

${BOLD}Task Priority Options:${NC}
  --critical, -A           Critical priority
  --high, -B               High priority
  --normal, -C             Normal priority (default)
  --low, -D                Low priority
  --someday, -E            Someday/maybe

${BOLD}Note Options:${NC}
  --project, -p            Create in Projects
  --area, -a               Create in Areas
  --resource, -r           Create in Resources

${BOLD}Environment Variables:${NC}
  PARA_BASE                Base directory (default: ~/Documents/PARA)
  PARA_LOG                 Log file (default: \$PARA_BASE/log.md)
  PARA_TASKS               Tasks file (default: \$PARA_BASE/tasks.md)

${BOLD}Examples:${NC}
  $(basename "$0") log "Had a great meeting with the team"
  $(basename "$0") task --critical "Fix production issue"
  $(basename "$0") task -B "Review pull request"
  $(basename "$0") note --project "New API Design"
  $(basename "$0") search "supervision tree"
  $(basename "$0") log-archive 2024-01-01
  $(basename "$0") task-archive
  $(basename "$0") project-archive

EOF
}

# Main script logic
main() {
    # Initialize PARA structure
    init_para
    
    # Parse command
    case "${1:-menu}" in
        log)
            shift
            add_log_entry "$@"
            ;;
        log-archive)
            shift
            archive_log "$@"
            ;;
        task)
            shift
            add_task "$@"
            ;;
        task-archive)
            archive_done_tasks
            ;;
        note)
            shift
            create_note "$@"
            ;;
        project|projects)
            goto_project
            ;;
        project-archive)
            archive_project
            ;;
        area|areas)
            goto_area
            ;;
        search-name)
            shift
            search_notes_by_name "$@"
            ;;
        search)
            shift
            search_notes_by_content "$@"
            ;;
        list)
            list_tasks
            ;;
        stats|statistics)
            show_stats
            ;;
        edit-log)
            open_log --edit
            ;;
        edit-tasks)
            ${EDITOR:-nvim} "$PARA_TASKS"
            ;;
        menu)
            show_menu
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Use '$(basename "$0") help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"